// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'library_settings.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$LibrarySettings {

@JsonKey(name: "coverAspectRatio") double? get coverAspectRatio;@JsonKey(name: "disableWatcher") bool? get disableWatcher;@JsonKey(name: "skipMatchingMediaWithAsin") bool? get skipMatchingMediaWithIsbn;@JsonKey(name: "skipMatchingMediaWithIsbn") bool? get skipMatchingMediaWithAsin;@JsonKey(name: "autoScanCronExpression") String? get autoScanCronExpression;@JsonKey(name: "audiobooksOnly") bool? get audiobooksOnly;@JsonKey(name: "epubsAllowScriptedContent") bool? get epubScriptedContent;@JsonKey(name: "hideSingleBookSeries") bool? get hideSingleBookSeries;@JsonKey(name: "onlyShowLaterBooksInContinueSeries") bool? get showLaterBooks;@JsonKey(name: "podcastSearchRegion") String? get podcastSearchRegion;@JsonKey(name: "metadataPrecedence") List<String>? get metadataPrecedence;
/// Create a copy of LibrarySettings
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LibrarySettingsCopyWith<LibrarySettings> get copyWith => _$LibrarySettingsCopyWithImpl<LibrarySettings>(this as LibrarySettings, _$identity);

  /// Serializes this LibrarySettings to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LibrarySettings&&(identical(other.coverAspectRatio, coverAspectRatio) || other.coverAspectRatio == coverAspectRatio)&&(identical(other.disableWatcher, disableWatcher) || other.disableWatcher == disableWatcher)&&(identical(other.skipMatchingMediaWithIsbn, skipMatchingMediaWithIsbn) || other.skipMatchingMediaWithIsbn == skipMatchingMediaWithIsbn)&&(identical(other.skipMatchingMediaWithAsin, skipMatchingMediaWithAsin) || other.skipMatchingMediaWithAsin == skipMatchingMediaWithAsin)&&(identical(other.autoScanCronExpression, autoScanCronExpression) || other.autoScanCronExpression == autoScanCronExpression)&&(identical(other.audiobooksOnly, audiobooksOnly) || other.audiobooksOnly == audiobooksOnly)&&(identical(other.epubScriptedContent, epubScriptedContent) || other.epubScriptedContent == epubScriptedContent)&&(identical(other.hideSingleBookSeries, hideSingleBookSeries) || other.hideSingleBookSeries == hideSingleBookSeries)&&(identical(other.showLaterBooks, showLaterBooks) || other.showLaterBooks == showLaterBooks)&&(identical(other.podcastSearchRegion, podcastSearchRegion) || other.podcastSearchRegion == podcastSearchRegion)&&const DeepCollectionEquality().equals(other.metadataPrecedence, metadataPrecedence));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,coverAspectRatio,disableWatcher,skipMatchingMediaWithIsbn,skipMatchingMediaWithAsin,autoScanCronExpression,audiobooksOnly,epubScriptedContent,hideSingleBookSeries,showLaterBooks,podcastSearchRegion,const DeepCollectionEquality().hash(metadataPrecedence));

@override
String toString() {
  return 'LibrarySettings(coverAspectRatio: $coverAspectRatio, disableWatcher: $disableWatcher, skipMatchingMediaWithIsbn: $skipMatchingMediaWithIsbn, skipMatchingMediaWithAsin: $skipMatchingMediaWithAsin, autoScanCronExpression: $autoScanCronExpression, audiobooksOnly: $audiobooksOnly, epubScriptedContent: $epubScriptedContent, hideSingleBookSeries: $hideSingleBookSeries, showLaterBooks: $showLaterBooks, podcastSearchRegion: $podcastSearchRegion, metadataPrecedence: $metadataPrecedence)';
}


}

/// @nodoc
abstract mixin class $LibrarySettingsCopyWith<$Res>  {
  factory $LibrarySettingsCopyWith(LibrarySettings value, $Res Function(LibrarySettings) _then) = _$LibrarySettingsCopyWithImpl;
@useResult
$Res call({
@JsonKey(name: "coverAspectRatio") double? coverAspectRatio,@JsonKey(name: "disableWatcher") bool? disableWatcher,@JsonKey(name: "skipMatchingMediaWithAsin") bool? skipMatchingMediaWithIsbn,@JsonKey(name: "skipMatchingMediaWithIsbn") bool? skipMatchingMediaWithAsin,@JsonKey(name: "autoScanCronExpression") String? autoScanCronExpression,@JsonKey(name: "audiobooksOnly") bool? audiobooksOnly,@JsonKey(name: "epubsAllowScriptedContent") bool? epubScriptedContent,@JsonKey(name: "hideSingleBookSeries") bool? hideSingleBookSeries,@JsonKey(name: "onlyShowLaterBooksInContinueSeries") bool? showLaterBooks,@JsonKey(name: "podcastSearchRegion") String? podcastSearchRegion,@JsonKey(name: "metadataPrecedence") List<String>? metadataPrecedence
});




}
/// @nodoc
class _$LibrarySettingsCopyWithImpl<$Res>
    implements $LibrarySettingsCopyWith<$Res> {
  _$LibrarySettingsCopyWithImpl(this._self, this._then);

  final LibrarySettings _self;
  final $Res Function(LibrarySettings) _then;

/// Create a copy of LibrarySettings
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? coverAspectRatio = freezed,Object? disableWatcher = freezed,Object? skipMatchingMediaWithIsbn = freezed,Object? skipMatchingMediaWithAsin = freezed,Object? autoScanCronExpression = freezed,Object? audiobooksOnly = freezed,Object? epubScriptedContent = freezed,Object? hideSingleBookSeries = freezed,Object? showLaterBooks = freezed,Object? podcastSearchRegion = freezed,Object? metadataPrecedence = freezed,}) {
  return _then(_self.copyWith(
coverAspectRatio: freezed == coverAspectRatio ? _self.coverAspectRatio : coverAspectRatio // ignore: cast_nullable_to_non_nullable
as double?,disableWatcher: freezed == disableWatcher ? _self.disableWatcher : disableWatcher // ignore: cast_nullable_to_non_nullable
as bool?,skipMatchingMediaWithIsbn: freezed == skipMatchingMediaWithIsbn ? _self.skipMatchingMediaWithIsbn : skipMatchingMediaWithIsbn // ignore: cast_nullable_to_non_nullable
as bool?,skipMatchingMediaWithAsin: freezed == skipMatchingMediaWithAsin ? _self.skipMatchingMediaWithAsin : skipMatchingMediaWithAsin // ignore: cast_nullable_to_non_nullable
as bool?,autoScanCronExpression: freezed == autoScanCronExpression ? _self.autoScanCronExpression : autoScanCronExpression // ignore: cast_nullable_to_non_nullable
as String?,audiobooksOnly: freezed == audiobooksOnly ? _self.audiobooksOnly : audiobooksOnly // ignore: cast_nullable_to_non_nullable
as bool?,epubScriptedContent: freezed == epubScriptedContent ? _self.epubScriptedContent : epubScriptedContent // ignore: cast_nullable_to_non_nullable
as bool?,hideSingleBookSeries: freezed == hideSingleBookSeries ? _self.hideSingleBookSeries : hideSingleBookSeries // ignore: cast_nullable_to_non_nullable
as bool?,showLaterBooks: freezed == showLaterBooks ? _self.showLaterBooks : showLaterBooks // ignore: cast_nullable_to_non_nullable
as bool?,podcastSearchRegion: freezed == podcastSearchRegion ? _self.podcastSearchRegion : podcastSearchRegion // ignore: cast_nullable_to_non_nullable
as String?,metadataPrecedence: freezed == metadataPrecedence ? _self.metadataPrecedence : metadataPrecedence // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}


/// @nodoc
@JsonSerializable()

class _LibrarySettings implements LibrarySettings {
  const _LibrarySettings({@JsonKey(name: "coverAspectRatio") this.coverAspectRatio, @JsonKey(name: "disableWatcher") this.disableWatcher, @JsonKey(name: "skipMatchingMediaWithAsin") this.skipMatchingMediaWithIsbn, @JsonKey(name: "skipMatchingMediaWithIsbn") this.skipMatchingMediaWithAsin, @JsonKey(name: "autoScanCronExpression") this.autoScanCronExpression, @JsonKey(name: "audiobooksOnly") this.audiobooksOnly, @JsonKey(name: "epubsAllowScriptedContent") this.epubScriptedContent, @JsonKey(name: "hideSingleBookSeries") this.hideSingleBookSeries, @JsonKey(name: "onlyShowLaterBooksInContinueSeries") this.showLaterBooks, @JsonKey(name: "podcastSearchRegion") this.podcastSearchRegion, @JsonKey(name: "metadataPrecedence") final  List<String>? metadataPrecedence}): _metadataPrecedence = metadataPrecedence;
  factory _LibrarySettings.fromJson(Map<String, dynamic> json) => _$LibrarySettingsFromJson(json);

@override@JsonKey(name: "coverAspectRatio") final  double? coverAspectRatio;
@override@JsonKey(name: "disableWatcher") final  bool? disableWatcher;
@override@JsonKey(name: "skipMatchingMediaWithAsin") final  bool? skipMatchingMediaWithIsbn;
@override@JsonKey(name: "skipMatchingMediaWithIsbn") final  bool? skipMatchingMediaWithAsin;
@override@JsonKey(name: "autoScanCronExpression") final  String? autoScanCronExpression;
@override@JsonKey(name: "audiobooksOnly") final  bool? audiobooksOnly;
@override@JsonKey(name: "epubsAllowScriptedContent") final  bool? epubScriptedContent;
@override@JsonKey(name: "hideSingleBookSeries") final  bool? hideSingleBookSeries;
@override@JsonKey(name: "onlyShowLaterBooksInContinueSeries") final  bool? showLaterBooks;
@override@JsonKey(name: "podcastSearchRegion") final  String? podcastSearchRegion;
 final  List<String>? _metadataPrecedence;
@override@JsonKey(name: "metadataPrecedence") List<String>? get metadataPrecedence {
  final value = _metadataPrecedence;
  if (value == null) return null;
  if (_metadataPrecedence is EqualUnmodifiableListView) return _metadataPrecedence;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of LibrarySettings
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LibrarySettingsCopyWith<_LibrarySettings> get copyWith => __$LibrarySettingsCopyWithImpl<_LibrarySettings>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LibrarySettingsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LibrarySettings&&(identical(other.coverAspectRatio, coverAspectRatio) || other.coverAspectRatio == coverAspectRatio)&&(identical(other.disableWatcher, disableWatcher) || other.disableWatcher == disableWatcher)&&(identical(other.skipMatchingMediaWithIsbn, skipMatchingMediaWithIsbn) || other.skipMatchingMediaWithIsbn == skipMatchingMediaWithIsbn)&&(identical(other.skipMatchingMediaWithAsin, skipMatchingMediaWithAsin) || other.skipMatchingMediaWithAsin == skipMatchingMediaWithAsin)&&(identical(other.autoScanCronExpression, autoScanCronExpression) || other.autoScanCronExpression == autoScanCronExpression)&&(identical(other.audiobooksOnly, audiobooksOnly) || other.audiobooksOnly == audiobooksOnly)&&(identical(other.epubScriptedContent, epubScriptedContent) || other.epubScriptedContent == epubScriptedContent)&&(identical(other.hideSingleBookSeries, hideSingleBookSeries) || other.hideSingleBookSeries == hideSingleBookSeries)&&(identical(other.showLaterBooks, showLaterBooks) || other.showLaterBooks == showLaterBooks)&&(identical(other.podcastSearchRegion, podcastSearchRegion) || other.podcastSearchRegion == podcastSearchRegion)&&const DeepCollectionEquality().equals(other._metadataPrecedence, _metadataPrecedence));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,coverAspectRatio,disableWatcher,skipMatchingMediaWithIsbn,skipMatchingMediaWithAsin,autoScanCronExpression,audiobooksOnly,epubScriptedContent,hideSingleBookSeries,showLaterBooks,podcastSearchRegion,const DeepCollectionEquality().hash(_metadataPrecedence));

@override
String toString() {
  return 'LibrarySettings(coverAspectRatio: $coverAspectRatio, disableWatcher: $disableWatcher, skipMatchingMediaWithIsbn: $skipMatchingMediaWithIsbn, skipMatchingMediaWithAsin: $skipMatchingMediaWithAsin, autoScanCronExpression: $autoScanCronExpression, audiobooksOnly: $audiobooksOnly, epubScriptedContent: $epubScriptedContent, hideSingleBookSeries: $hideSingleBookSeries, showLaterBooks: $showLaterBooks, podcastSearchRegion: $podcastSearchRegion, metadataPrecedence: $metadataPrecedence)';
}


}

/// @nodoc
abstract mixin class _$LibrarySettingsCopyWith<$Res> implements $LibrarySettingsCopyWith<$Res> {
  factory _$LibrarySettingsCopyWith(_LibrarySettings value, $Res Function(_LibrarySettings) _then) = __$LibrarySettingsCopyWithImpl;
@override @useResult
$Res call({
@JsonKey(name: "coverAspectRatio") double? coverAspectRatio,@JsonKey(name: "disableWatcher") bool? disableWatcher,@JsonKey(name: "skipMatchingMediaWithAsin") bool? skipMatchingMediaWithIsbn,@JsonKey(name: "skipMatchingMediaWithIsbn") bool? skipMatchingMediaWithAsin,@JsonKey(name: "autoScanCronExpression") String? autoScanCronExpression,@JsonKey(name: "audiobooksOnly") bool? audiobooksOnly,@JsonKey(name: "epubsAllowScriptedContent") bool? epubScriptedContent,@JsonKey(name: "hideSingleBookSeries") bool? hideSingleBookSeries,@JsonKey(name: "onlyShowLaterBooksInContinueSeries") bool? showLaterBooks,@JsonKey(name: "podcastSearchRegion") String? podcastSearchRegion,@JsonKey(name: "metadataPrecedence") List<String>? metadataPrecedence
});




}
/// @nodoc
class __$LibrarySettingsCopyWithImpl<$Res>
    implements _$LibrarySettingsCopyWith<$Res> {
  __$LibrarySettingsCopyWithImpl(this._self, this._then);

  final _LibrarySettings _self;
  final $Res Function(_LibrarySettings) _then;

/// Create a copy of LibrarySettings
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? coverAspectRatio = freezed,Object? disableWatcher = freezed,Object? skipMatchingMediaWithIsbn = freezed,Object? skipMatchingMediaWithAsin = freezed,Object? autoScanCronExpression = freezed,Object? audiobooksOnly = freezed,Object? epubScriptedContent = freezed,Object? hideSingleBookSeries = freezed,Object? showLaterBooks = freezed,Object? podcastSearchRegion = freezed,Object? metadataPrecedence = freezed,}) {
  return _then(_LibrarySettings(
coverAspectRatio: freezed == coverAspectRatio ? _self.coverAspectRatio : coverAspectRatio // ignore: cast_nullable_to_non_nullable
as double?,disableWatcher: freezed == disableWatcher ? _self.disableWatcher : disableWatcher // ignore: cast_nullable_to_non_nullable
as bool?,skipMatchingMediaWithIsbn: freezed == skipMatchingMediaWithIsbn ? _self.skipMatchingMediaWithIsbn : skipMatchingMediaWithIsbn // ignore: cast_nullable_to_non_nullable
as bool?,skipMatchingMediaWithAsin: freezed == skipMatchingMediaWithAsin ? _self.skipMatchingMediaWithAsin : skipMatchingMediaWithAsin // ignore: cast_nullable_to_non_nullable
as bool?,autoScanCronExpression: freezed == autoScanCronExpression ? _self.autoScanCronExpression : autoScanCronExpression // ignore: cast_nullable_to_non_nullable
as String?,audiobooksOnly: freezed == audiobooksOnly ? _self.audiobooksOnly : audiobooksOnly // ignore: cast_nullable_to_non_nullable
as bool?,epubScriptedContent: freezed == epubScriptedContent ? _self.epubScriptedContent : epubScriptedContent // ignore: cast_nullable_to_non_nullable
as bool?,hideSingleBookSeries: freezed == hideSingleBookSeries ? _self.hideSingleBookSeries : hideSingleBookSeries // ignore: cast_nullable_to_non_nullable
as bool?,showLaterBooks: freezed == showLaterBooks ? _self.showLaterBooks : showLaterBooks // ignore: cast_nullable_to_non_nullable
as bool?,podcastSearchRegion: freezed == podcastSearchRegion ? _self.podcastSearchRegion : podcastSearchRegion // ignore: cast_nullable_to_non_nullable
as String?,metadataPrecedence: freezed == metadataPrecedence ? _self._metadataPrecedence : metadataPrecedence // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}

// dart format on
